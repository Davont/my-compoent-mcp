确实，Manus 很聪明，他们把工具分成了 3 层：

第 1 层：函数调用 (Function Calling)

这是最基础的一层，只保留一小组固定的、原子化的函数，比如：读写文件、执行 Shell 命令、搜索文件等。在 LLM 的系统提示词中就只有这一层的工具定义，相对比较少，15 个以内，输入格式和输出格式都很清晰，不容易出错，但这里面有两个工具很特殊，一个是 Shell， 一个是 File。

第 2 层：沙箱工具 (Sandbox Utilities)

每个 Manus 会话都运行在一个完整的虚拟机沙箱里。就是原推文提到的，虚机预装了很多命令行工具，比如格式转换器、语音识别工具，甚至一个 mcp 命令行客户端。

然后这些工具都通过第 1 层中定义的 Shell 来调用，就是命令行工具，命令行调用。

但是这么多工具模型怎么知道呢？

Manus 在系统提示词里会直接告诉 LLM，在一个特定的文件夹里有很多预装的命令行工具。对于最常用的工具，直接列出它们的名字。不常用的，LLM 可以直接通过原推提到的命令列出所有命令行工具，通过 --help 参数来查看任何一个工具的用法，因为所有这些工具都是他们自己开发的，格式统一。

第 3 层：代码包与 API (Packages and APIs)

这一层其实就是 LLM 实时编写 Python 代码，通过代码实现更复杂的功能。比如用户想查询某个 API 的数据，可以直接用 Python 写一个函数，fetch API 的数据，并解析成需要的格式。

其实在 Codex 中，用 Python 代码当工具已经用的很多了。

由于复杂的运算都是代码完成的，返回给 主 Agent 的知识计算后的结果，所以并不会占用主 Agent 的上下文。

这样 3 层设计的好处是，从模型的角度看，它需要调用的工具就固定是第 1 层的十几个，而借助命令行和代码，它又可以衍生出无数的工具组合。

还有一点就是我在之前推文提到的子智能体，Manus 也是大量采用“智能体即工具 (agent as tool)”的模式。把子智能体当工具用，比如负责检索是一个子智能体，但是这个子智能体在主 Agent 看来就是一个工具。同时也可以很好的起到减少上下文的效果。



--------------------------------------------

Claude 的 Agent Skills 本质上是一种“上下文卸载”，把冗长的技能信息移出上下文，按需加载。巧的是最近 Manus 的 Peak 也分享一些“上下文卸载”的技巧。Manus 有很多工具，但是并不会把这些工具的完整定义告诉模型。那它怎么知道有哪些工具，又怎么调用它们呢？想象一下，给你一台新电脑，你怎么知道有哪些工具能用？普通用户会打开应用程序的列表，程序员会 `ls /usr/bin` 看一下有哪些命令可以用。

同样的，Manus 的解法是在系统提示词中，告诉模型在某个特定文件夹里，有许多预装的命令行实用工具。那些最常用的工具（ls、grep、cat、less、more等），就默认内置在系统提示里面的。不需要告诉模型如何使用这些工具，只需要列出工具名，然后告诉它可以使用 --help 参数来了解如何使用工具。最妙的是这些 shell 操作模型都是学过的，所以它的泛化能力很强，要加新的工具只需要往文件夹里面放一个命令就行。

我发现 Manus 真的是把 Unix 哲学贯彻到底了：KISS（Keep It Simple, Stupid）。